const std = @import("std");
const builtin = @import("builtin");

const Defaults = struct {
    pub const l1d_size_bytes: usize = 32 * 1024;
    pub const l1d_line_bytes: usize = 64;
    pub const l2_size_bytes: usize = 256 * 1024;
    pub const l3_size_bytes: usize = 8 * 1024 * 1024;
};

const CacheInfo = struct {
    detected: bool,
    method: []const u8,
    l1d_size_bytes: usize,
    l1d_line_bytes: usize,
    l2_size_bytes: usize,
    l3_size_bytes: usize,
    l1d_shared_by_logical_cpus: usize,
    l2_shared_by_logical_cpus: usize,
    l3_shared_by_logical_cpus: usize,
};

pub fn main() !void {
    const info = detectCacheInfo();

    var buf: [4096]u8 = undefined;
    var w = std.fs.File.stdout().writer(&buf);
    const out = &w.interface;

    try out.print("// Generated by `blazt` build-time CPU probe; DO NOT EDIT.\n", .{});
    try out.print("pub const detected: bool = {};\n", .{info.detected});
    try out.print("pub const method: []const u8 = \"{s}\";\n", .{info.method});
    try out.print("pub const l1d_size_bytes: usize = {};\n", .{info.l1d_size_bytes});
    try out.print("pub const l1d_line_bytes: usize = {};\n", .{info.l1d_line_bytes});
    try out.print("pub const l2_size_bytes: usize = {};\n", .{info.l2_size_bytes});
    try out.print("pub const l3_size_bytes: usize = {};\n", .{info.l3_size_bytes});
    try out.print("pub const l1d_shared_by_logical_cpus: usize = {};\n", .{info.l1d_shared_by_logical_cpus});
    try out.print("pub const l2_shared_by_logical_cpus: usize = {};\n", .{info.l2_shared_by_logical_cpus});
    try out.print("pub const l3_shared_by_logical_cpus: usize = {};\n", .{info.l3_shared_by_logical_cpus});
    try out.flush();
}

fn detectCacheInfo() CacheInfo {
    const is_x86 = comptime builtin.cpu.arch == .x86 or builtin.cpu.arch == .x86_64;

    if (!is_x86) {
        return .{
            .detected = false,
            .method = "default",
            .l1d_size_bytes = Defaults.l1d_size_bytes,
            .l1d_line_bytes = Defaults.l1d_line_bytes,
            .l2_size_bytes = Defaults.l2_size_bytes,
            .l3_size_bytes = Defaults.l3_size_bytes,
            .l1d_shared_by_logical_cpus = 1,
            .l2_shared_by_logical_cpus = 1,
            .l3_shared_by_logical_cpus = 1,
        };
    }

    return detectCacheInfoX86();
}

fn detectCacheInfoX86() CacheInfo {
    var info: CacheInfo = .{
        .detected = false,
        .method = "default",
        .l1d_size_bytes = Defaults.l1d_size_bytes,
        .l1d_line_bytes = Defaults.l1d_line_bytes,
        .l2_size_bytes = Defaults.l2_size_bytes,
        .l3_size_bytes = Defaults.l3_size_bytes,
        .l1d_shared_by_logical_cpus = 1,
        .l2_shared_by_logical_cpus = 1,
        .l3_shared_by_logical_cpus = 1,
    };

    const leaf0 = cpuid(0, 0);
    const max_basic = leaf0.eax;
    const vendor = vendorString(leaf0);

    const leaf_ext0 = cpuid(0x8000_0000, 0);
    const max_ext = leaf_ext0.eax;

    const is_amd = std.mem.eql(u8, vendor[0..], "AuthenticAMD");

    var cache_leaf: u32 = 0;
    if (is_amd and max_ext >= 0x8000_001D) {
        cache_leaf = 0x8000_001D;
        info.method = "cpuid.8000001D";
    } else if (max_basic >= 4) {
        cache_leaf = 4;
        info.method = "cpuid.4";
    } else {
        // Extremely old x86: keep defaults.
        return info;
    }

    var found_any = false;
    var subleaf: u32 = 0;
    while (subleaf < 32) : (subleaf += 1) {
        const leaf = cpuid(cache_leaf, subleaf);
        const cache_type: u32 = leaf.eax & 0x1F;
        if (cache_type == 0) break;

        // 1=data, 2=instruction, 3=unified
        const is_data_or_unified = cache_type == 1 or cache_type == 3;
        if (!is_data_or_unified) continue;

        const level: u32 = (leaf.eax >> 5) & 0x7;
        const shared_by: u32 = ((leaf.eax >> 14) & 0x0FFF) + 1;

        const line_size: u32 = (leaf.ebx & 0x0FFF) + 1;
        const partitions: u32 = ((leaf.ebx >> 12) & 0x03FF) + 1;
        const ways: u32 = ((leaf.ebx >> 22) & 0x03FF) + 1;
        const sets: u32 = leaf.ecx + 1;

        const size_u64: u64 =
            @as(u64, ways) *
            @as(u64, partitions) *
            @as(u64, line_size) *
            @as(u64, sets);
        if (size_u64 == 0) continue;

        const size_bytes: usize = @intCast(size_u64);
        const line_bytes: usize = @intCast(line_size);
        const shared_by_usize: usize = @intCast(@max(shared_by, 1));

        switch (level) {
            1 => {
                info.l1d_size_bytes = size_bytes;
                info.l1d_line_bytes = line_bytes;
                info.l1d_shared_by_logical_cpus = @max(info.l1d_shared_by_logical_cpus, shared_by_usize);
                found_any = true;
            },
            2 => {
                info.l2_size_bytes = size_bytes;
                info.l2_shared_by_logical_cpus = @max(info.l2_shared_by_logical_cpus, shared_by_usize);
                found_any = true;
            },
            3 => {
                info.l3_size_bytes = size_bytes;
                info.l3_shared_by_logical_cpus = @max(info.l3_shared_by_logical_cpus, shared_by_usize);
                found_any = true;
            },
            else => {},
        }
    }

    info.detected = found_any;
    return info;
}

const CpuidLeaf = packed struct {
    eax: u32,
    ebx: u32,
    ecx: u32,
    edx: u32,
};

/// Workaround for the C backend (stage2_c) which can't emit inline asm.
extern fn zig_x86_cpuid(leaf_id: u32, subid: u32, eax: *u32, ebx: *u32, ecx: *u32, edx: *u32) callconv(.c) void;

fn cpuid(leaf_id: u32, subid: u32) CpuidLeaf {
    var eax: u32 = undefined;
    var ebx: u32 = undefined;
    var ecx: u32 = undefined;
    var edx: u32 = undefined;

    if (builtin.zig_backend == .stage2_c) {
        zig_x86_cpuid(leaf_id, subid, &eax, &ebx, &ecx, &edx);
    } else {
        asm volatile ("cpuid"
            : [_] "={eax}" (eax),
              [_] "={ebx}" (ebx),
              [_] "={ecx}" (ecx),
              [_] "={edx}" (edx),
            : [_] "{eax}" (leaf_id),
              [_] "{ecx}" (subid),
        );
    }

    return .{ .eax = eax, .ebx = ebx, .ecx = ecx, .edx = edx };
}

fn vendorString(leaf0: CpuidLeaf) [12]u8 {
    var vendor: [12]u8 = undefined;

    const ebx_bytes: [4]u8 = @bitCast(leaf0.ebx);
    const edx_bytes: [4]u8 = @bitCast(leaf0.edx);
    const ecx_bytes: [4]u8 = @bitCast(leaf0.ecx);

    @memcpy(vendor[0..4], ebx_bytes[0..]);
    @memcpy(vendor[4..8], edx_bytes[0..]);
    @memcpy(vendor[8..12], ecx_bytes[0..]);

    return vendor;
}
